# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: Copyright 2023-2024 TotalEnergies.
# SPDX-FileContributor: Lucas Givord - Kitware
import pyvista as pv

from geos.trame.schema_generated.schema_mod import BoxType

import re


class BoxViewer:
    """A BoxViewer represents a Box and its intersected cell in a mesh.

    This mesh is represented in GEOS with a Box.
    """

    def __init__( self, mesh: pv.UnstructuredGrid, box: BoxType ) -> None:
        """Initialize the BoxViewer with a mesh and a box."""
        self._mesh: pv.UnstructuredGrid = mesh

        self._box: BoxType = box
        self._box_polydata: pv.PolyData = None
        self._box_polydata_actor: pv.Actor = None

        self._extracted_cells: pv.UnstructuredGrid = None
        self._extracted_cells_actor: pv.Actor = None

        self._compute_box_as_polydata()
        self._compute_intersected_cell()

    def get_box_polydata( self ) -> pv.PolyData | None:
        """Get the box polydata."""
        return self._box_polydata

    def get_box_polydata_actor( self ) -> pv.Actor:
        """Get the actor generated by a pv.Plotter for the box polydata."""
        return self._box_polydata_actor

    def get_extracted_cells( self ) -> pv.UnstructuredGrid | None:
        """Get the extracted cell polydata."""
        return self._extracted_cells

    def get_extracted_cells_actor( self ) -> pv.Actor | None:
        """Get the extracted cell polydata actor."""
        return self._extracted_cells_actor

    def set_box_polydata_actor( self, box_actor: pv.Actor ) -> None:
        """Set the actor generated by a pv.Plotter for the box polydata."""
        self._box_polydata_actor = box_actor

    def set_extracted_cells_actor( self, extracted_cell: pv.Actor ) -> None:
        """Set the actor generated by a pv.Plotter for the extracted cell."""
        self._extracted_cells_actor = extracted_cell

    def _compute_box_as_polydata( self ) -> None:
        """Create a polydata reresenting a BBox using pyvista and coordinates from the Geos Box."""
        bounding_box: list[ float ] = self._retrieve_bounding_box()
        self._box_polydata = pv.Box( bounds=bounding_box )

    def _retrieve_bounding_box( self ) -> list[ float ]:
        """This method converts bounding box information from Box into a list of coordinates readable by pyvista.

        e.g., this Box:

        <Box name="box_1"
             xMin="{ 1150, 700, 62 }"
             xMax="{ 1250, 800, 137 }"/>

        will return [1150, 1250, 700, 800, 62, 137].
        """
        # split str and remove brackets
        min_point_str = re.findall( r"-?\d+\.\d+|-?\d+", self._box.x_min )
        max_point_str = re.findall( r"-?\d+\.\d+|-?\d+", self._box.x_max )

        min_point = list( map( float, min_point_str ) )
        max_point = list( map( float, max_point_str ) )

        return [
            min_point[ 0 ],
            max_point[ 0 ],
            min_point[ 1 ],
            max_point[ 1 ],
            min_point[ 2 ],
            max_point[ 2 ],
        ]

    def _compute_intersected_cell( self ) -> None:
        """Extract the cells from the mesh that are inside the box."""
        ids = self._mesh.find_cells_within_bounds( self._box_polydata.bounds )

        saved_ids: list[ int ] = []

        for id in ids:
            cell: pv.vtkCell = self._mesh.GetCell( id )

            is_inside = self._check_cell_inside_box( cell, self._box_polydata.bounds )
            if is_inside:
                saved_ids.append( id )

        if len( saved_ids ) > 0:
            self._extracted_cells = self._mesh.extract_cells( saved_ids )

    def _check_cell_inside_box( self, cell: pv.Cell, box_bounds: list[ float ] ) -> bool:
        """Check if the cell is inside the box bounds.

        A cell is considered inside the box if his bounds are completely
        inside the box bounds.
        """
        cell_bounds = cell.GetBounds()
        is_inside_in_x = cell_bounds[ 0 ] >= box_bounds[ 0 ] and cell_bounds[ 1 ] <= box_bounds[ 1 ]
        is_inside_in_y = cell_bounds[ 2 ] >= box_bounds[ 2 ] and cell_bounds[ 3 ] <= box_bounds[ 3 ]
        is_inside_in_z = cell_bounds[ 4 ] >= box_bounds[ 4 ] and cell_bounds[ 5 ] <= box_bounds[ 5 ]

        return is_inside_in_x and is_inside_in_y and is_inside_in_z
